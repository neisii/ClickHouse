---
toc_priority: 0
toc_title: 개요
---

# ClickHouse 이란? {#what-is-clickhouse}

ClickHouse® 는 쿼리 온라인 분석 작업(OLAP)을 위한 열 지향 데이터베이스 관리 시스템이다.

일반적인 행 지향 DBMS에서는 다음 순서대로 데이터가 적재된다.

| Row | WatchID     | JavaEnable | Title              | GoodEvent | EventTime           |
|-----|-------------|------------|--------------------|-----------|---------------------|
| #0 | 89354350662 | 1          | Investor Relations | 1         | 2016-05-18 05:19:20 |
| #1 | 90329509958 | 0          | Contact us         | 1         | 2016-05-18 08:10:20 |
| #2 | 89953706054 | 1          | Mission            | 1         | 2016-05-18 07:38:00 |
| #N | …           | …          | …                  | …         | …                   |

다시 말해서, 한 행과 관련된 모든 값은 물리적으로 나란히 적재된다.

행 지향 DBMS의 예로 MySQL, Postgres, 및 MS SQL Server가 있다.

열 지향 DBMS에서는, 다음과 같이 데이터가 적재된다.

| Row:        | #0                 | #1                 | #2                 | #N |
|-------------|---------------------|---------------------|---------------------|-----|
| WatchID:    | 89354350662         | 90329509958         | 89953706054         | …   |
| JavaEnable: | 1                   | 0                   | 1                   | …   |
| Title:      | Investor Relations  | Contact us          | Mission             | …   |
| GoodEvent:  | 1                   | 1                   | 1                   | …   |
| EventTime:  | 2016-05-18 05:19:20 | 2016-05-18 08:10:20 | 2016-05-18 07:38:00 | …   |

다음 예제는 데이터가 배열된 순서만을 보여준다. 서로 다른 열의 값은 별도로, 동일한 열의 데이터는 함께 적재된다.

열 지향 DBMS의 예: Vertica, Paraccel (Actian Matrix와 Amazon Redshift), Sybase IQ, Exasol, Infobright, InfiniDB, MonetDB (VectorWise와 Actian Vector), LucidDB, SAP HANA, Google Dremel, Google PowerDrill, Druid, 및 kdb+.

다른 데이터 저장 순서가 상이한 시나리오에 더 적합하다. (원문: Different orders for storing data are better suited to different scenarios.)
데이터 액세스 시나리오는
 1) 쿼리 생성 빈도 및 비율
 2) 각 쿼리 유형(행, 열 및 바이트)에 대해 읽는 데이터의 양
 3) 데이터를 읽고 업데이트하는 관계
 4) 데이터의 작업 크기와 로컬 사용 빈도
 5) 트랜잭션 사용 여부
 6) 데이터 독립성
을 나타낸다. 즉, 물리적 데이터 복제, 논리적 무결성, 각 쿼리 유형에 대한 Latency 및 Throughput 등의 요건을 뜻한다.
* Latency : 어떤 트랜잭션의 요청시간으로부터 반환까지 걸리는 시간
* Throughput : 시간 당 처리 가능한 트랜잭션의 수

시스템에 대한 부하가 높을수록 사용되는 시나리오의 요건에 맞게 시스템을 설정하는 것이 더 중요하며, 이러한 설정은 상당히 상이한 시나리오에 동일하게 적합한 시스템은 없기 떄문에 더욱 세세해진다.
광범위한 시나리오를 시스템에 적용할 수 있다면, 모든 시나리오를 동등하게 잘 처리하지 못하거나, 하나 또는 몇몇의 가능한 시나리오만 잘 작동할 것이다.

## OLAP 시나리오의 주요 속성 {#key-properties-of-olap-scenario}

-   읽기 액세스가 대부분의 요청
-   데이터는 단일 행이 아닌 1000행 이상의 상당히 큰 배치로 업데이트되거나 전혀 업데이트되지 않음.
-   DB에 데이터가 추가되나 변경되지는 않음.
-   읽기 시, DB로부터 상당 수의 행이 추출되지만 열은 일부만 추출됨.
-   “방대”한 테이블. (= 많은 양의 컬럼을 포함.)
-   비교적 드문 쿼리. 일반적으로 서버 당 수백 개의 쿼리 또는 초당 수백 개의 쿼리임.
-   간단한 쿼리의 경우, 약 50ms 정도의 Latencty가 허용됨.
-   상당히 작은 컬럼 값. 예: 숫자 및 URL 당 60 바이트와 같은 짧은 문자열.
-   단일 쿼리 처리 시, 많은 throughput이 필요함. (예: 서버 당 최대 수십억 행)
-   트랜잭션이 필요 없음.
-   낮은 데이터 일관성
-   쿼리 당 하나의 큰 테이블이 존재하고, 이를 제외한 나머지 테이블은 작음. (원문: All tables are small, except for one.)
-   쿼리 결과는 소스 데이터보다 상당히 작다. (= 데이터가 필터링되거나 집계되므로 단일 서버의 RAM에 적합)

OLAP 시나리오는 OLTP 또는 Key-Value 액세스와 같은 다른 일반적인 시나리오와 매우 상이함을 쉽게 알 수 있다.
따라서, 적절한 성능을 얻기 위해 분석 쿼리를 처리하는데 OLTP 또는 Key-Value DB를 사용하려 시도하는 것은 무의미하다. 
예를 들어, 분석을 위해 MongoDB 또는 Redis를 사용해본다면 OLAP DB에 비해 성능이 매우 떨어지는 것을 알 수 있다.

## 열 지향 DB가 OLAP 시나리오에서 더 잘 작동하는 이유 {#why-column-oriented-databases-work-better-in-the-olap-scenario}

열 지향 DB는 대부분의 쿼리를 적어도 100배 더 빠르게 처리하기 때문에 OLAP 시나리오에 더 적합하다.
이에 대한 세부 설명은 아래에 서술하고 있지만 시각적으로 입증하기 더 쉽다.

**행 지향 DBMS**

![행 지향](images/row-oriented.gif#)

**열 지향 DBMS**

![열 지향](images/column-oriented.gif#)

차이가 보이는가?

### 입력/출력 {#inputoutput}

1.  열 지향 DB에서는 분석 쿼리를 수행하는데 있어 적은 수의 테이블 열만을 가지고 필요한 데이터만 읽을 수 있음. (예: 100개 중 5개의 열이 필요한 경우 입/출력이 20배 감소 가능)
2.  데이터는 패킷으로 읽기 때문에 압축하기 더 쉬움. 열의 데이터도 더 쉽게 압축할 수 있어 입/출력 볼륨이 더욱 줄어듦.
3.  입/출력 감소로 인해 더 많은 데이터가 시스템 캐시에 들어감.

예를 들어, "각 광고 플랫폼에 대한 레코드 수 계산"하는 쿼리가 있다. 이는 여기 압축되지 않은 1 바이트짜리 "광고 플랫폼 ID" 열을 읽어야 한다.
대부분의 트래픽이 광고 플랫폼에서 기인하지 않은 경우, 이 열을 10배 이상 압축할 수 있다. 
고속 압축 알고리즘을 사용하면, 초당 최소 몇 기가바이트의 압축되지 않은 데이터 속도로 데이터 압축을 해제할 수 있다.
다시 말해, 이 쿼리는 단일 서버에서 초당 약 수십억 행에 달하는 속도로 처리될 수 있다는 것이다. (* 실제로 달성한 속도임.)

### CPU {#cpu}

쿼리를 실행하려면 많은 수의 행이 처리되어야 하므로, 별도의 행 대신 전체 벡터에 대한 모든 연산을 dispatch 하거나, dispatch 비용이 거의 없도록 쿼리 엔진을 구현하는 데 도움이 된다.

이렇게 하지 않으면 반 정도의 디스크 서브 시스템만 사용할 수 있고, 쿼리 인터프린터가 불가피하게 CPU를 정지시킨다.
때문에 데이터는 가능한 열에 저장하고, 열별로 처리하는 것이 좋다.
It makes sense to both store data in columns and process it, when possible, by columns.

이와 같이 하기 위한 두 가지 방법:

1. 벡터 엔진: 모든 연산은 별도의 값 대신, 벡터로 기록됨. 이는 연산을 매우 자주 호출할 필요가 없고, dispatch 비용은 무시해도 되는 정도라는 뜻이다. 연산 코드에는 최적화된 반복문이 포함되어 있다.

2. 코드 생성: 쿼리에 대해 생성된 코드는 모든 간접 호출을 가지고 있음. 간단한 쿼리를 실행할 때는 의미가 없기 때문에 “일반” DB에서는 수행되지 않으나 예외도 존재함.
예: MemSQL은 SQL 쿼리를 처리할 때 코드 생성을 사용하여 latency를 줄임. (* 비교 시에 분석 DBMS는 latency가 아닌 throughput를 최적화해야 함.)

참고로, CPU 효율성을 위해 쿼리 언어는 선언적(SQL 또는 MDX)이거나 벡터(J, K) 이상이어야 한다. 쿼리는 최적화를 허용하는 암시적 루프만 포함해야 한다.

{## [원문](https://clickhouse.tech/docs/en/) ##}
